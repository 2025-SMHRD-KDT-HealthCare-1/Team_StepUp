<!DOCTYPE html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <title>StepUp Pushup Pose</title>
    <style>
      body {
        margin: 0;
        background: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
        overflow: hidden;
        color: #fff;
        font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI",
          sans-serif;
      }
      #container {
        position: relative;
        width: 800px;
        max-width: 100%;
        aspect-ratio: 16 / 9;
      }
      video,
      canvas {
        position: absolute;
        inset: 0;
        width: 100%;
        height: 100%;
        object-fit: cover;
        /* transform: scaleX(-1);  ê±°ìš¸ ëª¨ë“œ í•´ì œ ìœ ì§€ */
      }
      #overlayUi {
        position: absolute;
        left: 16px;
        top: 16px;
        z-index: 10;
        display: flex;
        flex-direction: column;
        gap: 8px;
      }
      .pill {
        padding: 6px 12px;
        border-radius: 999px;
        background: rgba(0, 0, 0, 0.6);
        font-size: 12px;
      }
    </style>

    <!-- MediaPipe Pose + Camera Utils CDN -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/pose.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3/drawing_utils.js"></script>
  </head>
  <body>
    <div id="container">
      <video id="video" playsinline></video>
      <canvas id="canvas"></canvas>

      <div id="overlayUi">
        <div class="pill" id="modeInfo">í‘¸ì‰¬ì—… ëª¨ë“œ Â· MediaPipe Pose</div>
        <div class="pill" id="setInfo">ì„¸íŠ¸: 1ì„¸íŠ¸ ì§„í–‰ ì¤‘ (10íšŒ ëª©í‘œ)</div>
        <div class="pill" id="countInfo">ë°˜ë³µ íšŸìˆ˜: 0íšŒ</div>
        <div class="pill" id="statusInfo">ìƒíƒœ: ì¤€ë¹„ ì¤‘...</div>
      </div>
    </div>

    <script>
      const videoEl = document.getElementById("video");
      const canvasEl = document.getElementById("canvas");
      const ctx = canvasEl.getContext("2d");

      const countInfo = document.getElementById("countInfo");
      const statusInfo = document.getElementById("statusInfo");
      const modeInfo = document.getElementById("modeInfo");
      const setInfo = document.getElementById("setInfo");

      let camera = null;

      // ============================
      //  ì •ìì„¸ ê¸°ì¤€ ê°ë„(ì½”ë© ìƒ˜í”Œ)
      // ============================
      //   elbow_angle          â‰ˆ  88.7Â°
      //   hip_angle            â‰ˆ 178.6Â°
      //   body_straight_angle  â‰ˆ 178.2Â°

      // ğŸ”¹ ë°˜ë³µ/ì„¸íŠ¸ ì¹´ìš´íŠ¸
      let totalRepCount = 0;
      let repsInCurrentSet = 0;
      let currentSetIndex = 1;

      let goodRepsInSet = 0; // ê¹Šì´ + ëª¸ ë¼ì¸ ëª¨ë‘ ê´œì°®ì€ ì •ìì„¸
      let badRepsInSet = 0; // ê¹Šì´ ë¶€ì¡± / ëª¸ ë¼ì¸ ë§ì´ ë¬´ë„ˆì§

      let phase = "up"; // up -> down -> up = 1íšŒ
      let countingEnabled = false;
      let lastRepTime = 0;
      let minAngleThisRep = 999;

      // ğŸ”¹ ê°€ì´ë“œ / ìº˜ë¦¬ë¸Œë ˆì´ì…˜ ìƒíƒœ
      let calibrated = false; // ì¤€ë¹„ìì„¸ í•œ ë²ˆ ë§ì·„ëŠ”ì§€
      let readyPoseFrames = 0; // ì¢‹ì€ ì¤€ë¹„ìì„¸ê°€ ì—°ì†ìœ¼ë¡œ ë‚˜ì˜¨ í”„ë ˆì„ ìˆ˜
      let lostPoseFrames = 0; // í¬ì¦ˆë¥¼ ìƒì–´ë²„ë¦° ì—°ì† í”„ë ˆì„ ìˆ˜

      // ğŸ”¹ ë‚œì´ë„/ëª©í‘œ
      let targetSetsPerDay = 1;
      let targetRepsPerSet = 10;

      // ğŸ”Š ì‹¤ì‹œê°„ ì½”ì¹­ ì¿¨íƒ€ì„
      let lastCoachTime = 0;

      // ğŸ”¹ ê°ë„ ì €ì¥
      let lastAngles = null;

      // ğŸ”¹ íŒ”ê¿ˆì¹˜ ê°ë„(ì„¸íŠ¸ ê¸°ì¤€ ë¶„ì„ìš©)
      let setElbowAngles = [];

      // ğŸ”¹ ì„¸íŠ¸ ì ìˆ˜ (ì˜ìƒ ì—…ë¡œë“œ ì‹œ ê°™ì´ ë„˜ê¸°ê¸°ìš©)
      let lastSetScore = null;

      // íŒ”ê¿ˆì¹˜ ê¸°ì¤€ (í‘¸ì‰¬ì—… ê¹Šì´/í­ íŒë‹¨ìš©)
      const DOWN_ELBOW_MAX = 120; // ì´ ì´í•˜ â†’ ë‚´ë ¤ê°„ ìì„¸
      const UP_ELBOW_MIN = 150; // ì´ ì´ìƒ â†’ ì˜¬ë¼ì˜¨ ìì„¸

      // "ì´ ì •ë„ ê°ë„ë©´ ì ë‹¹"í•œ ë²”ìœ„
      const IDEAL_ELBOW_MIN = 80;
      const IDEAL_ELBOW_MAX = 110;

      // ğŸ”¹ ê°€ì´ë“œë¼ì¸ ì´ë¯¸ì§€
      const guideImg = new Image();
      guideImg.src = "guideline_output.png";

      function resizeCanvas() {
        const rect = canvasEl.getBoundingClientRect();
        canvasEl.width = rect.width;
        canvasEl.height = rect.height;
      }
      window.addEventListener("resize", resizeCanvas);
      resizeCanvas();

      function getGuideRect() {
        const w = canvasEl.width * 1.0;
        const h = canvasEl.height * 0.9;
        const x = (canvasEl.width - w) / 2;
        const y = canvasEl.height - h - 20;
        return { x, y, w, h };
      }

      function getAngle(a, b, c) {
        const ab = { x: a.x - b.x, y: a.y - b.y };
        const cb = { x: c.x - b.x, y: c.y - b.y };
        const dot = ab.x * cb.x + ab.y * cb.y;
        const magAB = Math.sqrt(ab.x * ab.x + ab.y * ab.y);
        const magCB = Math.sqrt(cb.x * cb.x + cb.y * cb.y);
        const cos = dot / (magAB * magCB + 1e-6);
        const angle =
          (Math.acos(Math.min(Math.max(cos, -1), 1)) * 180) / Math.PI;
        return angle;
      }

      function computeAllAngles(landmarks) {
        const leftShoulder = landmarks[11];
        const leftElbow = landmarks[13];
        const leftWrist = landmarks[15];
        const rightShoulder = landmarks[12];
        const rightElbow = landmarks[14];
        const rightWrist = landmarks[16];

        const leftHip = landmarks[23];
        const rightHip = landmarks[24];
        const leftKnee = landmarks[25];
        const rightKnee = landmarks[26];
        const leftAnkle = landmarks[27];
        const rightAnkle = landmarks[28];

        const leftElbowAngle = getAngle(leftShoulder, leftElbow, leftWrist);
        const rightElbowAngle = getAngle(rightShoulder, rightElbow, rightWrist);
        const elbowAngle = (leftElbowAngle + rightElbowAngle) / 2;

        let hipAngle = null;
        if (leftHip && rightHip && leftKnee && rightKnee) {
          const leftHipAngle = getAngle(leftShoulder, leftHip, leftKnee);
          const rightHipAngle = getAngle(rightShoulder, rightHip, rightKnee);
          hipAngle = (leftHipAngle + rightHipAngle) / 2;
        }

        let bodyStraightAngle = null;
        if (leftHip && rightHip && leftAnkle && rightAnkle) {
          const leftBodyAngle = getAngle(leftShoulder, leftHip, leftAnkle);
          const rightBodyAngle = getAngle(rightShoulder, rightHip, rightAnkle);
          bodyStraightAngle = (leftBodyAngle + rightBodyAngle) / 2;
        }

        return {
          elbow_angle: elbowAngle,
          left_elbow_angle: leftElbowAngle,
          right_elbow_angle: rightElbowAngle,
          hip_angle: hipAngle,
          body_straight_angle: bodyStraightAngle,
        };
      }

      function checkPoseReady(landmarks) {
        let minY = 1,
          maxY = 0;
        for (const lm of landmarks) {
          if (lm.visibility !== undefined && lm.visibility < 0.1) continue;
          if (lm.y < minY) minY = lm.y;
          if (lm.y > maxY) maxY = lm.y;
        }
        const heightNorm = maxY - minY;

        const MIN_HEIGHT = 0.15;
        if (heightNorm < MIN_HEIGHT) {
          return {
            ready: false,
            message: "ë„ˆë¬´ ë©€ì–´ìš”. ì¹´ë©”ë¼ ìª½ìœ¼ë¡œ ì¡°ê¸ˆ ë” ë‹¤ê°€ì™€ ì£¼ì„¸ìš”.",
          };
        }

        const STANDING_HEIGHT = 0.75;
        if (heightNorm > STANDING_HEIGHT) {
          return {
            ready: false,
            message:
              "ì§€ê¸ˆì€ ì„œ ìˆëŠ” ìì„¸ì— ê°€ê¹ìŠµë‹ˆë‹¤. ëª¸ì„ ë” ë‚®ì¶°ì„œ í‘¸ì‰¬ì—… ì¤€ë¹„ìì„¸ë¥¼ ë§Œë“¤ì–´ ì£¼ì„¸ìš”.",
          };
        }

        const keyIdx = [11, 13, 15, 23, 25, 27];
        let visibleCnt = 0;
        for (const idx of keyIdx) {
          const lm = landmarks[idx];
          if (lm && (lm.visibility === undefined || lm.visibility > 0.2)) {
            visibleCnt++;
          }
        }

        if (visibleCnt < 3) {
          return {
            ready: false,
            message:
              "ëª¸ ì „ì²´ê°€ í™”ë©´ ì•ˆì— ëŒ€ëµ ë³´ì´ë„ë¡ í•œ ë²ˆë§Œ ë” ì¡°ì •í•´ ì£¼ì„¸ìš”.",
          };
        }

        return { ready: true, message: "ê´€ì ˆ ì¸ì‹ ì–‘í˜¸" };
      }

      function sendRealtimeCoach(mainMessage, detailMessage = "") {
        const now = Date.now();
        const COACH_COOLDOWN = 4000;
        if (now - lastCoachTime < COACH_COOLDOWN) return;
        lastCoachTime = now;

        if (window.parent && window.parent !== window) {
          window.parent.postMessage(
            {
              type: "STEPUP_REALTIME",
              mainMessage,
              detailMessage,
            },
            "*"
          );
        }
      }

      function exportReferenceAngles() {
        if (!lastAngles) return;

        const payload = {
          type: "PUSHUP_REF_ANGLE",
          timestamp: Date.now(),
          ...lastAngles,
        };

        console.log(JSON.stringify(payload));

        if (window.parent && window.parent !== window) {
          window.parent.postMessage(
            {
              type: "STEPUP_REF_ANGLE",
              angles: payload,
            },
            "*"
          );
        }
      }

      function recordElbowAngleForSet(angle) {
        if (!Number.isFinite(angle)) return;
        setElbowAngles.push(angle);
      }

      function getElbowFeedbackText(angles) {
        if (!angles || angles.length === 0) {
          return "ì´ë²ˆ ì„¸íŠ¸ì—ì„œëŠ” íŒ”ê¿ˆì¹˜ ê°ë„ ë°ì´í„°ë¥¼ ì¶©ë¶„íˆ ì–»ì§€ ëª»í–ˆìŠµë‹ˆë‹¤. ë‹¤ìŒ ì„¸íŠ¸ì—ì„œëŠ” í™”ë©´ ì¤‘ì•™ì—ì„œ ì¡°ê¸ˆë§Œ ë” ë˜ë ·í•˜ê²Œ ì›€ì§ì—¬ ë³´ì„¸ìš”.";
        }

        const sum = angles.reduce((acc, v) => acc + v, 0);
        const avg = sum / angles.length;

        if (avg < IDEAL_ELBOW_MIN - 5) {
          return "íŒ”ê¿ˆì¹˜ê°€ ëª¸í†µì— ë„ˆë¬´ ê°€ê¹ê²Œ ë¶™ì–´ ìˆìŠµë‹ˆë‹¤. ì† ê°„ê²©ì„ ì‚´ì§ ë” ë„“íˆê³ , íŒ”ê¿ˆì¹˜ê°€ ì˜†ìœ¼ë¡œ ì¡°ê¸ˆ ë” ë²Œì–´ì§€ë„ë¡ í•´ ì£¼ì„¸ìš”.";
        }
        if (avg > IDEAL_ELBOW_MAX + 5) {
          return "íŒ”ì´ ì¡°ê¸ˆ ë§ì´ ë²Œì–´ì ¸ ìˆìŠµë‹ˆë‹¤. ì† ê°„ê²©ì„ ì–´ê¹¨ë„ˆë¹„ ì •ë„ë¡œ ì¢íˆê³ , íŒ”ê¿ˆì¹˜ê°€ ëª¸í†µì—ì„œ 45ë„ ì •ë„ë§Œ ë²Œì–´ì§€ë„ë¡ ë§ì¶° ë³´ì„¸ìš”.";
        }

        return "íŒ”ê¿ˆì¹˜ ê°ë„ëŠ” ì „ë°˜ì ìœ¼ë¡œ ì¢‹ì€ í¸ì…ë‹ˆë‹¤. ì§€ê¸ˆ ëŠë‚Œì„ ìœ ì§€í•˜ë©´ì„œ ë‹¤ìŒ ì„¸íŠ¸ë„ ê°™ì€ í­ìœ¼ë¡œ ìœ ì§€í•´ ë³´ì„¸ìš”.";
      }

            function postSetFeedbackToParent() {
        // ì´ë²ˆ ì„¸íŠ¸ì—ì„œ ì‹¤ì œ ìˆ˜í–‰í•œ íšŸìˆ˜
        const total =
          repsInCurrentSet || goodRepsInSet + badRepsInSet || 1;

        // 1) ìì„¸(í¼) ì ìˆ˜: ì¢‹ì€ ìì„¸ ë¹„ìœ¨
        const qualityRatio =
          goodRepsInSet / ((goodRepsInSet + badRepsInSet) || 1); // 0~1
        const qualityScore = qualityRatio * 100; // 0~100

        // 2) ë³¼ë¥¨(íšŸìˆ˜) ì ìˆ˜: ëª©í‘œ ëŒ€ë¹„ ëª‡ % í–ˆëŠ”ì§€
        //    ì˜ˆ) ëª©í‘œ 10íšŒ ì¤‘ 1íšŒ â†’ 0.1, 5íšŒ â†’ 0.5, 10íšŒ ì´ìƒì´ë©´ 1ë¡œ ê³ ì •
        const volumeRatio = Math.min(
          total / (targetRepsPerSet || 1),
          1
        ); // 0~1
        const volumeScore = volumeRatio * 100; // 0~100

        // 3) ìµœì¢… ì ìˆ˜: í¼ 70% + ë³¼ë¥¨ 30% (ì›í•˜ë©´ ë¹„ìœ¨ ì¡°ì ˆí•´ë„ ë¨)
        const rawScore =
          qualityScore * 0.7 + volumeScore * 0.3;
        const score = Math.round(rawScore);
        lastSetScore = score;

        const mainMessage = `${currentSetIndex}ì„¸íŠ¸ (${total}íšŒ) ì™„ë£Œí–ˆìŠµë‹ˆë‹¤. ìˆ˜ê³ í•˜ì…¨ìŠµë‹ˆë‹¤.`;

        const baseSummary = `ì •ìì„¸(ì¢‹ì€ ìì„¸): ${goodRepsInSet}íšŒ
ë³´ì™„ì´ í•„ìš”í•œ ë™ì‘: ${badRepsInSet}íšŒ`;

        let detailMessage = "";

        if (badRepsInSet === 0) {
          detailMessage = `${baseSummary}

ì´ë²ˆ ì„¸íŠ¸ì—ì„œëŠ” ëŒ€ë¶€ë¶„ì˜ ë™ì‘ì„ ì•ˆì •ì ì¸ ìì„¸ë¡œ ìˆ˜í–‰í–ˆìŠµë‹ˆë‹¤.
íŒ”ê¿ˆì¹˜ ê°ë„ì™€ ëª¸ì˜ ë¼ì¸ë„ ì „ì²´ì ìœ¼ë¡œ ì˜ ìœ ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.
ì§€ê¸ˆ ëŠë‚Œì„ ê·¸ëŒ€ë¡œ ê¸°ì–µí•´ì„œ ë‹¤ìŒ ì„¸íŠ¸ë„ ê°™ì€ ë¦¬ë“¬ìœ¼ë¡œ ì´ì–´ê°€ ë³´ì„¸ìš”.`;
        } else {
          const elbowFeedback = getElbowFeedbackText(setElbowAngles);

          detailMessage = `${baseSummary}

${elbowFeedback}
ê°€ìŠ´ì€ ë°”ë‹¥ ìª½ìœ¼ë¡œ ì¡°ê¸ˆ ë” ë‚´ë ¤ê°€ë˜, í—ˆë¦¬ì™€ ì—‰ë©ì´ê°€ ê³¼í•˜ê²Œ êº¼ì§€ì§€ ì•Šë„ë¡
ì–´ê¹¨â€“ì—‰ë©ì´â€“ë°œëª©ì´ í•œ ì¤„ì— ê°€ê¹ê²Œ ìœ ì§€ë˜ë„ë¡ í•´ ì£¼ì„¸ìš”.`;
        }

        if (window.parent && window.parent !== window) {
          window.parent.postMessage(
            {
              type: "STEPUP_FEEDBACK",
              score,
              mainMessage,
              detailMessage,
              reps: total,
            },
            "*"
          );
        }

        statusInfo.textContent = `${currentSetIndex}ì„¸íŠ¸ê°€ ëë‚¬ìŠµë‹ˆë‹¤. ì ì‹œ í˜¸í¡ì„ ì •ë¦¬í•œ ë’¤ ë‹¤ìŒ ì„¸íŠ¸ë¥¼ ì¤€ë¹„í•´ ì£¼ì„¸ìš”.`;
      }


      // ğŸ” í—ˆë¦¬ êº¼ì§ / ì—‰ë©ì´ ë“¤ë¦¼ ì²´í¬
      function checkFormErrors(landmarks, elbowAngle, bodyStraightAngle) {
        const leftShoulder = landmarks[11];
        const rightShoulder = landmarks[12];
        const leftHip = landmarks[23];
        const rightHip = landmarks[24];
        const leftAnkle = landmarks[27];
        const rightAnkle = landmarks[28];

        if (
          !leftShoulder ||
          !rightShoulder ||
          !leftHip ||
          !rightHip ||
          !leftAnkle ||
          !rightAnkle
        ) {
          return;
        }

        // ëª¸ ë¼ì¸ì´ ëŒ€ëµ ê´œì°®ìœ¼ë©´(160Â° ì´ìƒ) ê²½ê³  ì•ˆ ë„ì›€
        if (!bodyStraightAngle || bodyStraightAngle >= 160) {
          return;
        }

        // ìƒë‹¨ êµ¬ê°„ì—ì„œë§Œ í—ˆë¦¬/ì—‰ë©ì´ ì²´í¬ (íŒ”ì´ ê±°ì˜ í´ì¡Œì„ ë•Œ)
        const isTopPhase = elbowAngle >= 140;
        if (!isTopPhase) return;

        const shoulderY = (leftShoulder.y + rightShoulder.y) / 2;
        const hipY = (leftHip.y + rightHip.y) / 2;
        const ankleY = (leftAnkle.y + rightAnkle.y) / 2;

        const midBodyY = (shoulderY + ankleY) / 2;
        const diff = hipY - midBodyY;

        const THRESH_WARN = 0.1;
        const THRESH_ERROR = 0.18;

        if (diff > THRESH_ERROR) {
          sendRealtimeCoach(
            "í—ˆë¦¬ê°€ ë§ì´ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ ìˆìŠµë‹ˆë‹¤.",
            "ë°°ì™€ í—ˆë¦¬ë¥¼ ëŒì–´ì˜¬ë ¤ì„œ ì–´ê¹¨ë¶€í„° ë°œê¹Œì§€ê°€ í•œ ì¤„ì— ê°€ê¹ë„ë¡ ë§ì¶° ì£¼ì„¸ìš”."
          );
        } else if (diff > THRESH_WARN) {
          sendRealtimeCoach(
            "í—ˆë¦¬ê°€ ì¡°ê¸ˆ ì•„ë˜ë¡œ ë‚´ë ¤ê°€ ìˆìŠµë‹ˆë‹¤.",
            "ëª¸í†µì„ ì¡°ê¸ˆë§Œ ë” ëŒì–´ì˜¬ë ¤ì„œ ì¼ì§ì„ ì— ê°€ê¹ê²Œ ë§ì¶° ì£¼ì„¸ìš”."
          );
        } else if (diff < -THRESH_ERROR) {
          sendRealtimeCoach(
            "ì—‰ë©ì´ê°€ ë§ì´ ì˜¬ë¼ê°€ ìˆìŠµë‹ˆë‹¤.",
            "ì—‰ë©ì´ë¥¼ ë‚´ë ¤ì„œ ì–´ê¹¨, ì—‰ë©ì´, ë°œëª©ì´ í•œ ì¤„ì— ê°€ê¹ë„ë¡ ë§ì¶° ì£¼ì„¸ìš”."
          );
        } else if (diff < -THRESH_WARN) {
          sendRealtimeCoach(
            "ì—‰ë©ì´ê°€ ì¡°ê¸ˆ ì˜¬ë¼ê°€ ìˆìŠµë‹ˆë‹¤.",
            "ì—‰ë©ì´ë¥¼ ì¡°ê¸ˆë§Œ ë‚´ë ¤ì„œ ëª¸ ë¼ì¸ì„ ì •ë¦¬í•´ ì£¼ì„¸ìš”."
          );
        }
      }

      // ===========================
      // ì„¸íŠ¸ ì˜ìƒ ë…¹í™” + ì—…ë¡œë“œ
      // ===========================
      let mediaRecorder = null;
      let recordedChunks = [];
      let isRecording = false;

      let lastUploadSetIndex = null;
      let lastUploadReps = null;
      let lastUploadScore = null;

      let recordingStartedForCurrentSet = false;

      function startRecordingIfPossible() {
        if (isRecording || recordingStartedForCurrentSet) return;

        const stream = videoEl.srcObject;
        if (!stream) {
          console.warn("ì˜ìƒ ìŠ¤íŠ¸ë¦¼ì´ ì—†ì–´ ë…¹í™”ë¥¼ ì‹œì‘í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.");
          return;
        }

        try {
          mediaRecorder = new MediaRecorder(stream, {
            mimeType: "video/webm;codecs=vp8",
          });
        } catch (err) {
          console.error("MediaRecorder ìƒì„± ì‹¤íŒ¨:", err);
          return;
        }

        recordedChunks = [];

        mediaRecorder.ondataavailable = (e) => {
          if (e.data && e.data.size > 0) {
            recordedChunks.push(e.data);
          }
        };

        mediaRecorder.onstop = async () => {
          try {
            if (!recordedChunks.length) return;

            const blob = new Blob(recordedChunks, { type: "video/webm" });
            recordedChunks = [];

            const formData = new FormData();
            formData.append("video", blob, "pushup-set.webm");

            const res = await fetch(
              "http://localhost:5000/api/upload-video",
              {
                method: "POST",
                body: formData,
              }
            );

            if (!res.ok) {
              console.error(
                "ì„¸íŠ¸ ì˜ìƒ ì—…ë¡œë“œ ì‹¤íŒ¨(res.ok=false):",
                res.status
              );
              return;
            }

            const data = await res.json();

            if (!data || !data.videoUrl) {
              console.error("ì„¸íŠ¸ ì˜ìƒ ì—…ë¡œë“œ ì‘ë‹µì— videoUrl ì—†ìŒ:", data);
              return;
            }

            console.log("ì„¸íŠ¸ ì˜ìƒ ì—…ë¡œë“œ ì™„ë£Œ:", data.videoUrl);

            if (window.parent && window.parent !== window) {
              window.parent.postMessage(
                {
                  type: "STEPUP_VIDEO_UPLOADED",
                  setIndex: lastUploadSetIndex,
                  reps: lastUploadReps,
                  score: lastUploadScore,
                  videoUrl: data.videoUrl,
                },
                "*"
              );
            }
          } catch (err) {
            console.error("ì„¸íŠ¸ ì˜ìƒ ì—…ë¡œë“œ ì‹¤íŒ¨(catch):", err);
          }
        };

        mediaRecorder.start();
        isRecording = true;
        recordingStartedForCurrentSet = true;
        console.log("ì„¸íŠ¸ ë…¹í™” ì‹œì‘");
      }

      function stopRecordingAndUpload(setIndex, reps, score) {
        if (!mediaRecorder || !isRecording) return;
        lastUploadSetIndex = setIndex;
        lastUploadReps = reps;
        lastUploadScore = score ?? null;
        isRecording = false;
        mediaRecorder.stop();
        console.log("ì„¸íŠ¸ ë…¹í™” ì¤‘ì§€, ì—…ë¡œë“œ ì‹œì‘");
      }

      function checkSetComplete() {
        if (repsInCurrentSet >= targetRepsPerSet) {
          const finishedSetIndex = currentSetIndex;
          const finishedReps = repsInCurrentSet;

          // âœ… ì„¸íŠ¸ ëª©í‘œ ì±„ì› ì„ ë•Œ: ìš”ì•½ í”¼ë“œë°± + ë…¹í™” ì¢…ë£Œ/ì—…ë¡œë“œ
          postSetFeedbackToParent();

          stopRecordingAndUpload(
            finishedSetIndex,
            finishedReps,
            lastSetScore
          );

          currentSetIndex += 1;
          repsInCurrentSet = 0;
          goodRepsInSet = 0;
          badRepsInSet = 0;
          minAngleThisRep = 999;
          setElbowAngles = [];
          lastSetScore = null;
          recordingStartedForCurrentSet = false;

          calibrated = false;
          readyPoseFrames = 0;

          countInfo.textContent = "ë°˜ë³µ íšŸìˆ˜: 0íšŒ";
          setInfo.textContent = `ì„¸íŠ¸: ${currentSetIndex}ì„¸íŠ¸ ì§„í–‰ ì¤‘ (ì„¸íŠ¸ë‹¹ ${targetRepsPerSet}íšŒ)`;
        }
      }

      function onResults(results) {
        ctx.save();
        ctx.clearRect(0, 0, canvasEl.width, canvasEl.height);

        if (results.image) {
          ctx.drawImage(results.image, 0, 0, canvasEl.width, canvasEl.height);
        }

        const guideRect = getGuideRect();
        if (!calibrated && guideImg.complete) {
          ctx.save();
          ctx.globalAlpha = 0.4;
          ctx.drawImage(
            guideImg,
            guideRect.x,
            guideRect.y,
            guideRect.w,
            guideRect.h
          );
          ctx.restore();
        }

        if (results.poseLandmarks) {
          const landmarks = results.poseLandmarks;
          lostPoseFrames = 0;

          lastAngles = computeAllAngles(landmarks);
          const elbowAngle = lastAngles.elbow_angle;
          const bodyStraight = lastAngles.body_straight_angle ?? 180;

          ctx.save();
          ctx.globalAlpha = 0.8;
          window.drawConnectors(ctx, landmarks, window.POSE_CONNECTIONS, {
            color: "#00fff0",
            lineWidth: 2,
          });
          window.drawLandmarks(ctx, landmarks, {
            color: "#ffff66",
            radius: 3,
          });
          ctx.restore();

          let depthFactor = (DOWN_ELBOW_MAX + 20 - elbowAngle) / 40;
          depthFactor = Math.max(0, Math.min(1, depthFactor));

          let coreFactor = (bodyStraight - 150) / 30;
          coreFactor = Math.max(0, Math.min(1, coreFactor));

          function highlightBone(i, j) {
            const a = {
              x: landmarks[i].x * canvasEl.width,
              y: landmarks[i].y * canvasEl.height,
            };
            const b = {
              x: landmarks[j].x * canvasEl.width,
              y: landmarks[j].y * canvasEl.height,
            };
            ctx.beginPath();
            ctx.moveTo(a.x, a.y);
            ctx.lineTo(b.x, b.y);
            ctx.stroke();
          }

          if (depthFactor > 0.05) {
            ctx.save();
            ctx.globalAlpha = 0.25 + 0.5 * depthFactor;
            ctx.strokeStyle = "#ff3b3b";
            ctx.lineWidth = 5 + 5 * depthFactor;

            highlightBone(11, 13);
            highlightBone(13, 15);
            highlightBone(12, 14);
            highlightBone(14, 16);

            ctx.restore();
          }

          if (coreFactor > 0.05) {
            ctx.save();
            ctx.globalAlpha = 0.18 + 0.4 * coreFactor;
            ctx.strokeStyle = "#ff7b7b";
            ctx.lineWidth = 4 + 4 * coreFactor;

            const shMid = {
              x: ((landmarks[11].x + landmarks[12].x) / 2) * canvasEl.width,
              y: ((landmarks[11].y + landmarks[12].y) / 2) * canvasEl.height,
            };
            const hipMid = {
              x: ((landmarks[23].x + landmarks[24].x) / 2) * canvasEl.width,
              y: ((landmarks[23].y + landmarks[24].y) / 2) * canvasEl.height,
            };

            ctx.beginPath();
            ctx.moveTo(shMid.x, shMid.y);
            ctx.lineTo(hipMid.x, hipMid.y);
            ctx.stroke();
            ctx.restore();
          }

          // ================= ìº˜ë¦¬ë¸Œë ˆì´ì…˜ =================
          if (!calibrated) {
            const poseInfo = checkPoseReady(landmarks);

            if (!poseInfo.ready) {
              readyPoseFrames = 0;
              statusInfo.textContent = `ìƒíƒœ: ${poseInfo.message}`;
              ctx.restore();
              return;
            }

            const elbowOk = elbowAngle >= 145 && elbowAngle <= 190;
            const bodyOk = bodyStraight >= 165 && bodyStraight <= 195;

            if (elbowOk && bodyOk) {
              readyPoseFrames++;
              statusInfo.textContent =
                "ìƒíƒœ: ì¢‹ìŠµë‹ˆë‹¤. ì´ ìì„¸ë¥¼ ì ì‹œ ìœ ì§€í•´ ì£¼ì„¸ìš”.";

              if (readyPoseFrames >= 60) {
                calibrated = true;
                statusInfo.textContent =
                  "ìƒíƒœ: ì¤€ë¹„ ì™„ë£Œ. ì´ì œ ì¹´ìš´íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.";

                if (countingEnabled && !isRecording) {
                  console.log("ê°€ì´ë“œ ì‚¬ë¼ì§ â†’ ë…¹í™” ì‹œì‘");
                  startRecordingIfPossible();
                }
              }
            } else {
              readyPoseFrames = 0;
              statusInfo.textContent =
                "ìƒíƒœ: ê°€ì´ë“œì— ë§ê²Œ ëª¸ì„ ì¼ì§ì„ ìœ¼ë¡œ ë§ì¶° ì£¼ì„¸ìš”.";
            }

            if (!calibrated) {
              ctx.restore();
              return;
            }
          }

          // ================= ì¹´ìš´íŠ¸ / ì½”ì¹­ =================
          const leftShoulder = landmarks[11];
          const leftElbow = landmarks[13];
          const leftWrist = landmarks[15];
          const rightShoulder = landmarks[12];
          const rightElbow = landmarks[14];
          const rightWrist = landmarks[16];

          const valid =
            leftShoulder &&
            leftElbow &&
            leftWrist &&
            rightShoulder &&
            rightElbow &&
            rightWrist &&
            leftShoulder.visibility > 0.3 &&
            leftElbow.visibility > 0.3 &&
            leftWrist.visibility > 0.3 &&
            rightShoulder.visibility > 0.3 &&
            rightElbow.visibility > 0.3 &&
            rightWrist.visibility > 0.3;

          if (valid) {
            if (countingEnabled) {
              checkFormErrors(landmarks, elbowAngle, bodyStraight);
            }

            if (!countingEnabled) {
              statusInfo.textContent = `ìƒíƒœ: ì¤€ë¹„ ì™„ë£Œ. íŒ”ê¿ˆì¹˜ ${elbowAngle.toFixed(
                1
              )}Â°`;
            } else {
              const now = Date.now();

              const isDownPose = elbowAngle <= DOWN_ELBOW_MAX;
              const isUpPose = elbowAngle >= UP_ELBOW_MIN;

              if (phase === "up" && isDownPose) {
                phase = "down";
                minAngleThisRep = elbowAngle;
                statusInfo.textContent = `ìƒíƒœ: ì•„ë˜ë¡œ ì´ë™ ì¤‘. íŒ”ê¿ˆì¹˜ ${elbowAngle.toFixed(
                  1
                )}Â°`;
              } else if (phase === "down") {
                if (elbowAngle < minAngleThisRep) {
                  minAngleThisRep = elbowAngle;
                }

                if (isUpPose) {
                  if (now - lastRepTime > 500) {
                    phase = "up";
                    lastRepTime = now;

                    totalRepCount += 1;
                    repsInCurrentSet += 1;

                    recordElbowAngleForSet(minAngleThisRep);

                    countInfo.textContent = `ë°˜ë³µ íšŸìˆ˜: ${repsInCurrentSet}íšŒ`;
                    statusInfo.textContent = `ìƒíƒœ: ìœ„(1íšŒ ì™„ë£Œ). íŒ”ê¿ˆì¹˜ ${elbowAngle.toFixed(
                      1
                    )}Â°`;

                    const goodDepth =
                      minAngleThisRep <= DOWN_ELBOW_MAX - 10;

                    const bodyOkNow = bodyStraight >= 160;

                    if (goodDepth && bodyOkNow) {
                      goodRepsInSet += 1;
                      exportReferenceAngles();

                      if (Math.random() < 0.3) {
                        sendRealtimeCoach(
                          "ì¢‹ì•„ìš”, ê¹Šì´ë„ ìì„¸ë„ ì¢‹ìŠµë‹ˆë‹¤.",
                          "ì§€ê¸ˆì²˜ëŸ¼ ê°€ìŠ´ì„ ì¶©ë¶„íˆ ë‚´ë¦¬ë©´ì„œë„ ëª¸ ë¼ì¸ì„ ì˜ ìœ ì§€í•´ ì£¼ì„¸ìš”."
                        );
                      }
                    } else {
                      badRepsInSet += 1;

                      if (!goodDepth) {
                        sendRealtimeCoach(
                          "ì¡°ê¸ˆë§Œ ë” ê¹Šê²Œ ë‚´ë ¤ê°€ ë³´ì„¸ìš”.",
                          "íŒ”ê¿ˆì¹˜ê°€ ë” ì ‘íˆë„ë¡ ê°€ìŠ´ì„ ë°”ë‹¥ ìª½ìœ¼ë¡œ ì¡°ê¸ˆ ë” ë‚´ë ¤ì£¼ì„¸ìš”."
                        );
                      }
                    }

                    minAngleThisRep = 999;
                    checkSetComplete();
                  }
                } else {
                  // âœ… ìì„¸ ì¢‹ì„ ë•Œ ë¬¸êµ¬
                  statusInfo.textContent =
                    "ìƒíƒœ: ìì„¸ ì¢‹ìŠµë‹ˆë‹¤. ìì„¸ë¥¼ ìœ ì§€í•´ ì£¼ì„¸ìš”.";
                }
              } else {
                statusInfo.textContent = `ìƒíƒœ: ì´ë™ ì¤‘. íŒ”ê¿ˆì¹˜ ${elbowAngle.toFixed(
                  1
                )}Â°`;
              }
            }
          } else {
            statusInfo.textContent = "ìƒíƒœ: ìì„¸ ì¸ì‹ ì¤‘ì…ë‹ˆë‹¤.";
          }
        } else {
          lostPoseFrames++;

          if (calibrated && lostPoseFrames > 60) {
            calibrated = false;
            readyPoseFrames = 0;
            recordingStartedForCurrentSet = false;
            statusInfo.textContent =
              "ìƒíƒœ: ìì„¸ê°€ ì˜¤ë˜ ì¸ì‹ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤. ê°€ì´ë“œì— ë‹¤ì‹œ ë§ì¶° ì£¼ì„¸ìš”.";
          } else if (!calibrated) {
            statusInfo.textContent = "ìƒíƒœ: ìì„¸ ì¸ì‹ ì¤‘ì…ë‹ˆë‹¤.";
          }
        }

        ctx.restore();
      }

      const pose = new window.Pose({
        locateFile: (file) =>
          `https://cdn.jsdelivr.net/npm/@mediapipe/pose@0.5/${file}`,
      });

      pose.setOptions({
        modelComplexity: 1,
        smoothLandmarks: true,
        enableSegmentation: false,
        minDetectionConfidence: 0.5,
        minTrackingConfidence: 0.5,
      });

      pose.onResults(onResults);

      async function startCameraInternal() {
        if (camera) {
          console.log("ì´ë¯¸ ì¹´ë©”ë¼ê°€ ì‹œì‘ëœ ìƒíƒœì…ë‹ˆë‹¤.");
          return;
        }

        statusInfo.textContent = "ìƒíƒœ: ì¹´ë©”ë¼ ì¤€ë¹„ ì¤‘ì…ë‹ˆë‹¤...";

        try {
          camera = new window.Camera(videoEl, {
            onFrame: async () => {
              await pose.send({ image: videoEl });
            },
            width: 640,
            height: 360,
          });

          await camera.start();
          statusInfo.textContent = "ìƒíƒœ: ì¸ì‹ ì¤‘ì…ë‹ˆë‹¤.";
          console.log("ì¹´ë©”ë¼ ì‹œì‘ ì„±ê³µ");
        } catch (err) {
          console.error("ì¹´ë©”ë¼ ì‹œì‘ ì‹¤íŒ¨:", err);
          statusInfo.textContent =
            "ì¹´ë©”ë¼ ê¶Œí•œì„ í—ˆìš©í–ˆëŠ”ì§€ í™•ì¸í•´ ì£¼ì„¸ìš” (ì£¼ì†Œì°½ì˜ ì¹´ë©”ë¼ ì•„ì´ì½˜).";
          alert(
            "ì¹´ë©”ë¼ë¥¼ ì‚¬ìš©í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.\në¸Œë¼ìš°ì € ì£¼ì†Œì°½ ì˜¤ë¥¸ìª½ì˜ ì¹´ë©”ë¼ ì•„ì´ì½˜ì—ì„œ 'í—ˆìš©'ìœ¼ë¡œ ë°”ê¿”ì£¼ì„¸ìš”."
          );
        }
      }

      function startCounting() {
        countingEnabled = true;
        phase = "up";
        totalRepCount = 0;
        repsInCurrentSet = 0;
        currentSetIndex = 1;
        goodRepsInSet = 0;
        badRepsInSet = 0;
        lastRepTime = 0;
        minAngleThisRep = 999;
        lastAngles = null;
        setElbowAngles = [];
        lastSetScore = null;

        calibrated = false;
        readyPoseFrames = 0;
        lostPoseFrames = 0;

        recordingStartedForCurrentSet = false;
        isRecording = false;
        mediaRecorder = null;
        recordedChunks = [];

        countInfo.textContent = "ë°˜ë³µ íšŸìˆ˜: 0íšŒ";
        setInfo.textContent = `ì„¸íŠ¸: ${currentSetIndex}ì„¸íŠ¸ ì§„í–‰ ì¤‘ (ì„¸íŠ¸ë‹¹ ${targetRepsPerSet}íšŒ)`;
        statusInfo.textContent = "ìƒíƒœ: ì¸ì‹ ì¤‘ì…ë‹ˆë‹¤.";

        if (window.parent && window.parent !== window) {
          window.parent.postMessage(
            {
              type: "STEPUP_REALTIME",
              mainMessage: `${currentSetIndex}ì„¸íŠ¸ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤. ì²œì²œíˆ ì²« ë™ì‘ì„ ë‚´ë ¤ê°€ ë³´ì„¸ìš”.`,
              detailMessage: "",
            },
            "*"
          );
        }
      }

      window.startCamera = function () {
        startCounting();
        startCameraInternal();
      };

      function stopAnalysisNow() {
        console.log("ìˆ˜ë™ ë¶„ì„ ì¤‘ì§€ ìš”ì²­");
        countingEnabled = false;

        // âœ… ìµœì†Œ 1íšŒ ì´ìƒ í–ˆìœ¼ë©´: ì„¸íŠ¸ ìš”ì•½ í”¼ë“œë°± + ë…¹í™” ì¢…ë£Œ/ì—…ë¡œë“œ
        if (repsInCurrentSet > 0) {
          // 1) ë¨¼ì € FEEDBACK(ì ìˆ˜/ë¬¸êµ¬) ìƒì„±í•´ì„œ React(Pose.jsx)ë¡œ ì „ì†¡
          postSetFeedbackToParent();

          // 2) ì„¸íŠ¸ ì˜ìƒ ë…¹í™” ì¤‘ì´ë©´, ê°™ì€ ì„¸íŠ¸ ê¸°ë¡ìœ¼ë¡œ ì—…ë¡œë“œ
          if (isRecording) {
            const finishedSetIndex = currentSetIndex;
            const finishedReps = repsInCurrentSet;
            const finishedScore = lastSetScore;

            stopRecordingAndUpload(
              finishedSetIndex,
              finishedReps,
              finishedScore
            );
          }
        } else {
          // 0íšŒì¼ ë•ŒëŠ” ì˜ˆì „ì²˜ëŸ¼ ì˜ìƒë§Œ ì •ë¦¬(ë…¹í™” ì¤‘ì´ë©´ ì—…ë¡œë“œ)í•˜ê³  í”¼ë“œë°±ì€ ì•ˆ ë³´ëƒ„
          if (isRecording) {
            stopRecordingAndUpload(currentSetIndex, repsInCurrentSet, lastSetScore);
          }
        }

        statusInfo.textContent = "ìƒíƒœ: ë¶„ì„ì´ ì¤‘ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.";
      }

      window.addEventListener("message", (event) => {
        if (!event.data || typeof event.data !== "object") return;
        const { type } = event.data;

        if (type === "STEPUP_START_CAMERA") {
          console.log("STEPUP_START_CAMERA ìˆ˜ì‹ ");
          startCounting();
          startCameraInternal();
        }

        if (type === "STEPUP_SET_TARGET") {
          console.log("ëª©í‘œ ì„¸íŒ…:", event.data);
          targetSetsPerDay = event.data.setsPerDay ?? targetSetsPerDay;
          targetRepsPerSet = event.data.repsPerSet ?? targetRepsPerSet;

          if (!targetRepsPerSet || targetRepsPerSet < 2) {
            targetRepsPerSet = 10;
          }

          setInfo.textContent = `ì„¸íŠ¸: ${currentSetIndex}ì„¸íŠ¸ ì§„í–‰ ì¤‘ (ì„¸íŠ¸ë‹¹ ${targetRepsPerSet}íšŒ)`;
          modeInfo.textContent = `í‘¸ì‰¬ì—… ëª¨ë“œ Â· ëª©í‘œ: ${targetSetsPerDay}ì„¸íŠ¸ Ã— ${targetRepsPerSet}íšŒ`;
        }

        if (type === "STEPUP_STOP_ANALYSIS") {
          console.log("STEPUP_STOP_ANALYSIS ìˆ˜ì‹ ");
          stopAnalysisNow();
        }
      });
    </script>
  </body>
</html>
